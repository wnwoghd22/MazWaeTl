# 오타

> 백만 개의 케이스 중 한 개를 찾는 것보다 100줄의 코드에서 한 줄을 찾는 것이 훨씬 쉽다.

## 디버깅의 기본: 다시 읽어보기

대부분 틀린 코드의 반례는 0~10으로 구성할 수 있습니다. 작은 숫자들만 가지고도 로직의 허점이나 경계값을 충분히 확인할 수 있습니다. 하지만 경우의 수는 기하급수적으로 늘어나서 숫자를 6개 이상 조합하게 되면 고려해야 할 테스트케이스의 수는 백만 개를 가뿐히 넘습니다. 반면 코딩테스트를 위해 작성되는 코드는 길어야 100줄을 넘지 않을 것입니다. 백만 개의 케이스 중 한 개를 찾기 위해 아무 숫자나 넣어보며 기도하는 것보다는 지금까지 작성된 코드를 천천히 읽어보는 것이 훨씬 빠르고 쉽습니다.

코드를 천천히 읽어야 하는 이유는 여러 가지가 있지만, 가장 중요한 것은 **오타**를 찾기 위해서입니다.

## 오타를 확인하자.

오타는 생각보다 훨씬 더 다양한 결과로 이어집니다. 코딩테스트에서뿐 아니라 실무에서도 치명적인 문제가 발생할 수 있습니다.

### 출력문 오타

모든 로직이 완벽한 것 같은데, 대체 왜 틀렸는지 모르겠다면 스크롤을 과감히 내려서 맨 마지막 줄을 확인해볼 필요가 있습니다.

- 대소문자를 잘못 썼거나 (`Hello world!`)
- `data - date`, `text - test` 등 헷갈려 잘못 썼거나
- 띄워쓰기를 잘못 했거나
- 1-base인데 0-base를 썼거나

하는 이유로 틀리는 경우가 꽤 있습니다. 찾고나면 가장 허탈하기도 합니다. 하지만 명심해야 하는 것은 이 또한 실수라는 것입니다. 실무에서 중요한 결제 서류나 config 파일에 이런 실수를 했다면 그저 오답 처리로 끝나지 않을지도 모릅니다. 백엔드 properties 파일의 DB 주소에 낸 알아차리기 힘든 오타 하나 때문에 주말 저녁 내도록 디버깅한 적이 있는 사람들은 어떤 얘긴지 알겠죠?

### 변수 오타

맨 마지막 줄에 오타가 없다면 변수가 사용되는 부분들을 집중적으로 살펴보는 것이 좋습니다.

- 격자판을 탐색하는 DFS 및 BFS 문제에서 가로 세로 인덱스를 바꿔 썼거나
- 다중 반복문에서 i, j 등 인덱스를 잘못 썼거나
- 코드를 복사-붙여넣기하다가 미처 고치지 못한 변수가 남았거나

할 때가 자주 있습니다. 이 경우 다소 예측하기 어려운 결과를 내놓을 수 있습니다.

- 단순 오답: 잘못된 위치를 찾아가거나
- 무한 루프: i를 조건으로 하는 while문에서 j를 조작한다거나
- OutOfIndex: 너무 먼 위치를 찾아가거나
- Segmentation Fault: 전혀 예상하지 못한 위치를 찾아가거나
- Undefined Behavior: 최악의 경우 값이 초기화되지 않은 변수에 접근하거나

하는 등 사실상 모든 문제의 원인이 될 수 있습니다.