# 철저한 조건분기: 저주 받은 오븐 시계

모든 프로그램들은 다 뜯어보면 결국 할당문, 조건문, 반복문만 남습니다. 조건문을 잘 쓰는 것은 중요합니다. 그런 의미에서 정말 저주 받은 문제가 하나 있습니다.

지금은 A시 B분입니다. C분 후에 타이머가 울릴텐데, 그 떄의 시간을 출력하는 것이 목표입니다.

if문도 배웠고, 연산자 활용도 자신 있으니 상황을 분석하기 시작합니다.

*B + C가 60이 되지 않으면, 시간 단위로 넘어가지 않을 거야. 60이 되면, 1시간 늘어나고 0분이 되겠네. 60을 넘어간다면 넘어간 만큼 시간이 늘어나겠지.*

이를 바탕으로 코드를 작성해나갑니다.

```py
a, b, c = #input 

if b + c < 60:
    pass

else:
    pass
```

첫 번째 케이스는 쉬워보입니다.

```py
a, b, c = #input 

if b + c < 60:
    print(a, b + c)

else:
    pass
```

60분이 되는 경우를 처리해줘야 할 것 같습니다.

```py
a, b, c = #input 

if b + c < 60:
    print(a, b + c)

else:
    if b + c == 60:
        b = 0
        print(a + 1, b)
```

60이 넘어갈 때도 처리해줍니다.

```py
a, b, c = #input 

if b + c < 60:
    print(a, b + c)

else:
    if b + c == 60:
        b = 0
        a += 1
    else:
        a += (b + c) // 60
        b = (b + c) % 60
    print(a, b)
```

정수 나눗셈, 나머지 연산까지 써서 꽤 까다로운 부분도 잘 넘겼습니다. 모든 경우를 처리했다고 생각했는데, 채점 결과는 틀렸습니다. 대체 뭐가 잘못된 건지 찾아보니 a가 23일 때 시간을 0으로 처리해줘야 했단 걸 깜빡했네요.

```py
a, b, c = #input 

if m + c < 60:
    print(a, b + c)

else:
    if b + c == 60 and a < 23:
        b = 0
        a += 1
    elif a == 23:
        b = 0
        a = 0
    else:
        a += (b + c) // 60
        b = (b + c) % 60
        if a == 24:
            a = 0
    print(a, b)
```

또 어딘가 틀렸습니다. 코드는 점점 길고 복잡해집니다.

---

## 잘못된 조건문 유형

단순히 현재 시각에서 c분 앞 또는 뒤의 시각을 출력하는 문제의 질문 수가 600개에 가깝습니다. 오답들에서 몇 가지 패턴을 발견할 수 있습니다.

1. 경계값 오류 (이상, 이하, 초과, 미만)
2. 복합명제 남용
    - 두 가지 이상의 조건을 함께 확인
    - 너무 많은 else 문의 사용
3. 잘못된, 또는 충분하지 않은 조건 검사

대부분의 경우 철저하지 않은 조건문이 문제를 야기하고, 그에 따른 부작용으로 두 번 출력된다든지 출력이 아예 되지 않는 상황으로까지 이어질 수 있습니다.

### 경계값 오류

조건문 분기 자체는 잘 구성했으나 조건식이 틀린 경우입니다. 이상, 이하 등 경계값을 포함하는지 여부는 분명히 해두는 것이 좋습니다. 

```py
if b + c > 60: # 그럼 60은?
    b = (b + c) % 60
```

### 복합명제의 남용

조건 분기를 최대한 자세히 나누고 복합적인 조건에 대해 각자 처리하도록 합니다. 하나의 if 문 안에서 60분을 넘는지와 24시를 넘는지 동시에 확인하는 코드 등이 여기 속합니다. 또는 여러 줄에 걸쳐 `if ... else if ...` 문으로 복합적인 경우를 나누기도 합니다. 두 가지 이상을 동시에 확인하는 조건문이 나쁘다는 것이 아닙니다. 집합을 허술하게 가르는 복합명제가 문제입니다.

```py
if b + c >= 60 and a < 23:
    # ...
else:
    # ???
```

두 번째 `else`문에는 `b + c < 60` 또는 `a >= 23`로 전혀 상관없는 경우들이 모이게 됩니다. 이 집합 안에는 `b + c >= 60` 또는 `a < 23`인 경우도 여전히 포함되어 있습니다. 이를 제대로 처리하기 위해서는 결국 다시 `if else`문을 중첩할 가능성이 높아집니다. 몇 단계에 걸쳐 이루어지는 조건 분기는 뒤로 갈수록 어떻게 나뉘는지 파악하기 어려워집니다. 허술한 조건분기는 커버되지 않는 상태를 남겨서 문제를 일으킵니다. 상호배타적이지 않은 조건분기는 코드의 불필요한 중복을 일으킵니다. 잘게 쪼개진 조건분기 내에서 중복되는 출력문이 함께 문제를 일으키면서 두 번 출력하거나 아예 출력하지 않고 넘어가기도 합니다.

### 잘못된 조건 검사

예시로 든 문제는 비교적 단순한 편이어서 이런 유형은 잘 없으나, 간혹 조건식이 논리적으로 틀리는 경우가 있습니다. 어떤 조건식에 대해, 조건식과 그 **대우**는 서로 반대인 진리값을 갖습니다. 그러나 **역**과 **이**는 전혀 독립적인 진리값을 갖기 때문에 조건식으로 쓸 수 없는데, 간혹 역 또는 이를 조건 분기에 쓰는 경우가 있습니다. 대표적인 경우가 이상, 이하인 조건식을 초과, 미만으로 바꾸지 않고 그대로 이상, 이하로 방향만 바꾸는 것입니다. 이 경우 경계값에서의 진리값이 뒤집힙니다.

### 충분하지 않은 조건 검사

오븐 시계 문제는 요리하는 데 필요한 시간이 60분 이내라고 한 적이 없습니다. 오히려 1000분까지 커질 수 있기 때문에 다음과 같은 코드는 문제의 조건에 의해 철저하지 않은 조건분기가 됩니다.

```py
if b + c > 60:
    b = b + c - 60 # 한 시간 빼는 것으로 충분할까요?
else: 
    # ...
```

## 해결 방법

간결하고 명확한 조건식을 구성하는 데 공식 같은 게 있었다면 개발자 연봉은 다 똑같았을 겁니다. 명세서에서 요구하는 기능은 상황에 따라 다르고, 조건문도 그에 따라 변합니다. 결국 꾸준히 연습하는 수밖에 없습니다. 클린 코드 전략으로 조기 반환, 조건 함수, 열거 패턴 같은 방식을 찾아볼 수 있지만 여기선 더 근원적인 문제를 다루고 있으므로 넘어가겠습니다.

1. 복합명제 남용: 그림 그려보기
2. 잘못된 조건 검사: 부등호 확인하기, 괄호 확인하기
3. 충분하지 않은 조건 검사: 코드와 문제를 다시 잘 읽어보기
4. 정말로 `if-else`문을 쓸 필요가 있는지 검토하기

### 그림 그려보기

코딩테스트를 준비하는 사람들 중 흐름도를 제대로 그리면서 문제를 푸는 비율이 얼마나 될까요? 조건 분기가 너무 복잡하다고 생각된다면 한 눈에 보이는 그림을 그려 정리해보는 것이 도움이 됩니다.

### 부등호, 괄호 확인하기

경계값에서 혹은 연산자 우선순위 등으로 인해 발생하는 문제는 조건식을 다시 잘 쓰는 것으로 해결할 수 있습니다.

### 코드와 문제를 다시 잘 읽어보기

명세서를 잘못 읽어 제품에 필요한 기능을 넣지 못했다면 그건 개발자 책임입니다. 문제를 정확히 읽고 구현하는 것은 기본입니다.

중요한 경계값을 잘못 썼거나 오타가 없는지 확인해봅니다. `24`로 써야할 것을 `23`으로 쓰지는 않았는지 등입니다. 점차 어렵고 복잡한 코드를 구현할 필요가 있을 땐 주요 경계값 등은 코드 맨 앞에 **상수로 선언**해 두는 것도 좋습니다.

### 정말로 `if-else` 문을 쓸 필요가 있는지 검토하기

조건분기를 반드시 써야할 때도 있지만, 쓰지 않는 것이 더 명확히 의도를 전달할 때도 있습니다.

b + c를 60으로 나눈 나머지는 결국 60 미만이 됩니다. b + c를 60으로 나눈 몫은 a에 더해지는 시간이 됩니다. b + c가 60 미만이라면 그 몫은 0이므로 굳이 조건분기로 처리할 필요가 없습니다. 식을 정리하면 다음과 같이 됩니다.

```py
h = (a + (b + c) // 60) % 24
m = (b + c) % 60
```